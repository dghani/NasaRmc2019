#include "tfr_mission_control/mission_control.h"

#include <pluginlib/class_list_macros.h>

namespace tfr_mission_control {

    /* ========================================================================== */
    /* Constructor/Destructor                                                     */
    /* ========================================================================== */

    /*
     * First thing to get called, NOTE ros::init called by superclass
     * Not needed here
     * */
     MissionControl::MissionControl()
        : rqt_gui_cpp::Plugin(),
         widget(nullptr),
         robotEnabled{false},
         robotMode{teleoperated},
         inputType{keyboard}
    {
        setObjectName("MissionControl");
    }

    /* NOTE: I think these QObjects have reference counting and are held by
     * smart pointers under the hood. (I never ever see any qt programmers
     * implement destructors or free memory on QObjects in any tutorial, example
     * code or forum). However I do not know for sure, so I do it here to make
     * myself feel better, and it doesn't seem to complain.
     * */
    MissionControl::~MissionControl()
    {
        delete widget;
        delete countdownClock;
        robotControlsTab->~RobotControlsTab();
    }

    /* ========================================================================== */
    /* Initialize/Shutdown                                                        */
    /* ========================================================================== */

    /*
     * Actually sets up all of the components on the screen and registers
     * application context. Some of this code is boilerplate generated by that
     * "catkin_creat_rqt" script, and it looked complicated, so I just took it
     * at face value. I'll mark those sections with a //boilerplate annotation.
     * */
    void MissionControl::initPlugin(qt_gui_cpp::PluginContext& context)
    {
        //boilerplate
        widget = new QWidget();
        ui.setupUi(widget);
        if (context.serialNumber() > 1)
        {
            widget->setWindowTitle(widget->windowTitle() +
                    " (" + QString::number(context.serialNumber()) + ")");
        }

        //sets our window active, and makes sure we handle keyboard events
        widget->setFocusPolicy(Qt::StrongFocus);
        widget->installEventFilter(this);
        //boilerplate
        context.addWidget(widget);

        countdownClock = new QTimer(this);

        QWidget* tab = ui.tab_widget->widget(0);//Robot Controls Tab
        robotControlsTab = static_cast<RobotControlsTab*>(tab);


        /*Slots*/
        
        //Disable/enable buttons
        connect(ui.e_stop_button, &QPushButton::clicked, this, &MissionControl::emergencyStop);
        connect(ui.enable_button, &QPushButton::clicked, this, &MissionControl::enableRobot);
        connect(ui.disable_button, &QPushButton::clicked, this, &MissionControl::disableRobot);

        //Robot modes
        connect(ui.teleop_button, &QPushButton::clicked, [this] () {setRobotMode(MissionControl::RobotMode::teleoperated);});
        connect(ui.auto_button, &QPushButton::clicked, [this] () {setRobotMode(MissionControl::RobotMode::autonomous);});

        //Control modes
        connect(ui.keyboard_button, &QPushButton::clicked, [this]() {setInputType(MissionControl::InputType::keyboard);});
        connect(ui.controller_button, &QPushButton::clicked, [this]() {setInputType(MissionControl::InputType::controller);});

        //Clock
        connect(countdownClock, &QTimer::timeout, this, &MissionControl::renderClock);

        //Tab slots
        robotControlsTab->setupSignalsAndSlots();

        //Startup stuff
        setupButtons();
        robotControlsTab->setupROS(getNodeHandle());
        
        //binPositionSub = getNodeHandle().subscribe("/tf", 5, &MissionControl::updateBinPosition, this);
        ROS_ERROR("BEFORE");

        //Test* test = new Test();
        //test->binPositionSub = getNodeHandle().subscribe("/tf", 5, &tfr_mission_control::RobotControlsTab::updateBinPosition, this);

        //robotControlsTab->binPositionSub = getNodeHandle().subscribe("/tf", 5, &MissionControl::updateBinPosition, this);
        ROS_ERROR("AFTER");
        //robotControlsTab->binPositionSub.transport_hints = ros::TransportHints().unreliable();
    }


    /*
     * This get's called before the destructor, and apparently we need to
     * deallocate our ros objects manually here according to the documentation.
     * Publishers and subscribers especially
     * */
    void MissionControl::shutdownPlugin()
    {

    }

    /*
    * Enables the robot and runs its selected mode.
    * 
    */
    void MissionControl::enableRobot() {
        startTimeService();
        ui.enable_button->setEnabled(false);
        ui.disable_button->setEnabled(true);

        //Prevent people from selecting mode while running
        ui.teleop_button->setEnabled(false);
        ui.auto_button->setEnabled(false);

        //Prevent people from selecting input type while running
        ui.keyboard_button->setEnabled(false);
        ui.controller_button->setEnabled(false);

        //Turn on the tab buttons if it is in teleop
        if (robotMode == teleoperated) {
            robotControlsTab->setButtonAvailability(true);
        }
    }

    /*
    * Disables the robot. Stops the mission clock
    * 
    */
    void MissionControl::disableRobot() {
        ui.enable_button->setEnabled(true);
        ui.disable_button->setEnabled(false);

        //Used to renable the mode buttons 
        setRobotMode(robotMode);

        //Used to renable the input type buttons
        setInputType(inputType);

        countdownClock->stop();
        ui.time_display->display(0);

        robotControlsTab->setButtonAvailability(false);


    }

    /*
    * Sets the mode of the robot and updates the gui
    * to reflect that
    */
    void MissionControl::setRobotMode(MissionControl::RobotMode mode) {
        robotMode = mode;

        switch (mode) {
            case(MissionControl::RobotMode::autonomous):
                ui.teleop_button->setEnabled(true);
                ui.auto_button->setEnabled(false);
                break;
            case(MissionControl::RobotMode::teleoperated):
                ui.teleop_button->setEnabled(false);
                ui.auto_button->setEnabled(true);
                break;
        }
    }

    /*
    * Sets the control type to be the specified mode
    */
    void MissionControl::setInputType(MissionControl::InputType mode) {
        inputType = mode;

        switch (mode) {
            case (MissionControl::InputType::controller):
                ui.keyboard_button->setEnabled(true);
                ui.controller_button->setEnabled(false);
                break;
            case (MissionControl::InputType::keyboard):
                ui.keyboard_button->setEnabled(false);
                ui.controller_button->setEnabled(true);
                break;
        }
    }


    void MissionControl::emergencyStop() {

    }

    /*
    * Starts the timer. I do not know how it works,
    * I just copy/pasted the method that already was here in the old gui
    */
    void MissionControl::startTimeService() {
        std_srvs::Empty start;
        ros::service::call("start_mission", start);
        countdownClock->start(500);
    }

    /*
    * Renders the clock on the gui. 
    * Copy/pasted method from old gui
    */
    void MissionControl::renderClock() {
        tfr_msgs::DurationSrv remaining_time;
        ros::service::call("time_remaining", remaining_time);
        ui.time_display->display(remaining_time.response.duration.toSec());
    }

    /*
    * This sets up the initial conditions, visual wise, when the 
    * application starts
    */
    void MissionControl::setupButtons() {
        //Enable/disable buttons
        ui.enable_button->setEnabled(true);
        ui.disable_button->setEnabled(false);

        //Robot Mode, default is teleop
        ui.teleop_button->setEnabled(false);
        ui.auto_button->setEnabled(true);

        //Input type, default is keyboard
        ui.keyboard_button->setEnabled(false);
        ui.controller_button->setEnabled(true);

        robotControlsTab->setButtonAvailability(false);


    }


}

PLUGINLIB_EXPORT_CLASS(tfr_mission_control::MissionControl,
        rqt_gui_cpp::Plugin)
