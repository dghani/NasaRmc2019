#include "tfr_mission_control/mission_control.h"

#include <pluginlib/class_list_macros.h>

namespace tfr_mission_control {

    /* ========================================================================== */
    /* Constructor/Destructor                                                     */
    /* ========================================================================== */

    /*
     * First thing to get called, NOTE ros::init called by superclass
     * Not needed here
     * */
     MissionControl::MissionControl()
        : rqt_gui_cpp::Plugin(),
        widget(nullptr)
    {
        setObjectName("MissionControl");
    }

    /* NOTE: I think these QObjects have reference counting and are held by
     * smart pointers under the hood. (I never ever see any qt programmers
     * implement destructors or free memory on QObjects in any tutorial, example
     * code or forum). However I do not know for sure, so I do it here to make
     * myself feel better, and it doesn't seem to complain.
     * */
    MissionControl::~MissionControl()
    {
        delete widget;
    }

    /* ========================================================================== */
    /* Initialize/Shutdown                                                        */
    /* ========================================================================== */

    /*
     * Actually sets up all of the components on the screen and registers
     * application context. Some of this code is boilerplate generated by that
     * "catkin_creat_rqt" script, and it looked complicated, so I just took it
     * at face value. I'll mark those sections with a //boilerplate annotation.
     * */
    void MissionControl::initPlugin(qt_gui_cpp::PluginContext& context)
    {
        //boilerplate
        widget = new QWidget();
        ui.setupUi(widget);
        if (context.serialNumber() > 1)
        {
            widget->setWindowTitle(widget->windowTitle() +
                    " (" + QString::number(context.serialNumber()) + ")");
        }

        //sets our window active, and makes sure we handle keyboard events
        widget->setFocusPolicy(Qt::StrongFocus);
        widget->installEventFilter(this);
        //boilerplate
        context.addWidget(widget);

        setupToolTips();

    }

    /*
     * This get's called before the destructor, and apparently we need to
     * deallocate our ros objects manually here according to the documentation.
     * Publishers and subscribers especially
     * */
    void MissionControl::shutdownPlugin()
    {

    }

    /*
    * I tried to use Qt Desinger's toolTip thing, but it did not work.
    * So I am implementing it via code instead
    * 
    */
    void MissionControl::setupToolTips() {

        //General Info Panel Tool Tips
        ui.enable_button->setToolTip("Enables the robot");
        ui.enable_button->setToolTipDuration(5000);

        ui.disable_button->setToolTip("Disables the robot");
        ui.disable_button->setToolTipDuration(5000);

        ui.teleop_button->setToolTip("Sets the robot to the teleoperated mode");
        ui.teleop_button->setToolTipDuration(5000);

        ui.auto_button->setToolTip("Sets the robot to the autonomous mode");
        ui.auto_button->setToolTipDuration(5000);

        ui.keyboard_button->setToolTip("Sets the control type to a keyboard");
        ui.keyboard_button->setToolTipDuration(5000);

        ui.controller_button->setToolTip("Sets the control type to a controller");
        ui.controller_button->setToolTipDuration(5000);

    }

   
}

PLUGINLIB_EXPORT_CLASS(tfr_mission_control::MissionControl,
        rqt_gui_cpp::Plugin)
